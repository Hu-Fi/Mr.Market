import {
  decodeArbitrageMemo,
  decodeArbitrageCreateMemo,
  decodeMarketMakingMemo,
  decodeSpotMemo,
  encodeArbitrageCreateMemo,
  memoPreDecode,
  decodeMarketMakingCreateMemo,
  encodeMarketMakingCreateMemo,
} from './memo';
import {
  TARDING_TYPE_MAP,
  SPOT_ORDER_TYPE_MAP,
  SPOT_EXCHANGE_MAP,
} from 'src/common/constants/memo';

describe('decodeArbitrageCreateMemo', () => {
  it('test', () => {
    const params = {
      version: 1,
      tradingType: 'Arbitrage',
      action: 'create',
      arbitragePairId: '7fef38d5-5644-42e9-9abb-9f8e1a51ff36',
      orderId: '3a0a5fd3-786d-419c-8cbc-a5179dce9d95',
      rewardAddress: '0x1AE60D36412a6745fce4d4935FF5Bf2b8139a371',
    };
    const memo = encodeArbitrageCreateMemo(params);
    const feMemo =
      '3NBCZM5GMuRKQKKTGxBEMgAEVdoEek2A9My9BgMBM2k2QkhDzxdWQAyDP1cgTdFgS6eo8pfAo5ij6vNT';
    console.log(`memo: ${memo}`);
    console.log(`femo: ${feMemo}`);
    expect(memo).toEqual(feMemo);

    const { payload, version, tradingTypeKey } = memoPreDecode(memo);
    console.log(`payload: ${payload}`);
    console.log(`version: ${version}`);
    console.log(`tradingTypeKey: ${tradingTypeKey}`);
    const result = decodeArbitrageCreateMemo(payload);
    console.log(`result: ${JSON.stringify(result)}`);
    expect(result).toEqual(params);
  });

  it('should throw an error for invalid checksum (memo without 4 bytes checksum)', () => {
    const invalidMemo =
      '3NB9J7yT6msdnWVto4W5LxRyQndoLfzwA8TJcuBtKcTWLqG5n8S3pUBBiVjVLR9PekLU8sRo6h7M';
    expect(() => {
      const { payload } = memoPreDecode(invalidMemo);
      decodeArbitrageCreateMemo(payload);
    }).toThrow('Invalid checksum');
  });

  it('should return arbtirage memo details', () => {
    const encodedMemo = encodeArbitrageCreateMemo({
      version: 1,
      tradingType: 'Arbitrage',
      action: 'create',
      arbitragePairId: '0776b00f-95c0-46f9-85e4-7b8e7ca51e94',
      orderId: 'b0177350-ae29-43ec-a26e-d46f821e416e',
      rewardAddress: '0x0000000000000000000000000000000000000000',
    });
    console.log(`encodeArbitrageCreateMemo: ${encodedMemo}`);
    const { payload } = memoPreDecode(encodedMemo);
    const result = decodeArbitrageCreateMemo(payload);
    expect(result).toEqual({
      version: 1,
      tradingType: 'Arbitrage',
      action: 'create',
      arbitragePairId: '0776b00f-95c0-46f9-85e4-7b8e7ca51e94',
      orderId: 'b0177350-ae29-43ec-a26e-d46f821e416e',
      rewardAddress: '0x0000000000000000000000000000000000000000',
    });
  });
});

describe('decodeMarketMakingCreateMemo', () => {
  it('should throw an error for invalid checksum (memo without 6 bytes)', () => {
    const invalidMemo =
      '3NB9J7yT6msdnWVto4W5LxRyQndoLfzwA8TJcuBtKcTWLqG5n8S3pUBBiVjVLR9PekLU8sRo6h';
    expect(() => {
      const { payload } = memoPreDecode(invalidMemo);
      decodeMarketMakingCreateMemo(payload);
    }).toThrow('Invalid checksum');
  });

  it('should return market making memo details', () => {
    const encodedMemo = encodeMarketMakingCreateMemo({
      version: 1,
      tradingType: 'Market Making',
      action: 'create',
      marketMakingPairId: '0776b00f-95c0-46f9-85e4-7b8e7ca51e94',
      orderId: 'b0177350-ae29-43ec-a26e-d46f821e416e',
      rewardAddress: '0x0000000000000000000000000000000000000000',
    });
    console.log(`encodeMarketMakingCreateMemo: ${encodedMemo}`);
    const { payload } = memoPreDecode(encodedMemo);
    const result = decodeMarketMakingCreateMemo(payload);
    expect(result).toEqual({
      version: 1,
      tradingType: 'Market Making',
      action: 'create',
      marketMakingPairId: '0776b00f-95c0-46f9-85e4-7b8e7ca51e94',
      orderId: 'b0177350-ae29-43ec-a26e-d46f821e416e',
      rewardAddress: '0x0000000000000000000000000000000000000000',
    });
  });
});

describe.skip('decodeSpotMemo', () => {
  it('should decode a valid spot memo correctly', () => {
    const validMemo = 'U1A6TEI6MDE6WjdHQzo1MDAwMDo';
    const memo = Buffer.from(validMemo, 'base64').toString('utf-8');
    const expectedResult = {
      tradingType: TARDING_TYPE_MAP['SP'],
      spotOrderType: SPOT_ORDER_TYPE_MAP['LB'],
      exchangeName: SPOT_EXCHANGE_MAP['01'],
      destId: 'Z7GC',
      limitPrice: '50000',
      refId: '',
    };

    const decodedMemo = decodeSpotMemo(memo);
    expect(decodedMemo).toEqual(expectedResult);
  });

  it('should handle memo generated by frontend', () => {
    const validMemo = 'U1A6TUI6MDQ6WjdHQzo2OTYyNy45Og';
    const memo = Buffer.from(validMemo, 'base64').toString('utf-8');
    const expectedResult = {
      tradingType: TARDING_TYPE_MAP['SP'],
      spotOrderType: SPOT_ORDER_TYPE_MAP['MB'],
      exchangeName: SPOT_EXCHANGE_MAP['04'],
      destId: 'Z7GC',
      limitPrice: '69627.9',
      refId: '',
    };
    const decodedMemo = decodeSpotMemo(memo);
    expect(decodedMemo).toEqual(expectedResult);
  });

  it('should handle a memo without limit price and refId', () => {
    const memoWithoutLimitPriceAndRefId = 'U1A6TUI6MDI6TU1NTQ==';
    const memo = Buffer.from(memoWithoutLimitPriceAndRefId, 'base64').toString(
      'utf-8',
    );
    const expectedResult = {
      tradingType: TARDING_TYPE_MAP['SP'],
      spotOrderType: SPOT_ORDER_TYPE_MAP['MB'],
      exchangeName: SPOT_EXCHANGE_MAP['02'],
      destId: 'MMMM',
      limitPrice: undefined,
      refId: undefined,
    };

    const decodedMemo = decodeSpotMemo(memo);
    expect(decodedMemo).toEqual(expectedResult);
  });

  it('should throw an error for an invalid base64 encoded memo', () => {
    const invalidMemo = 'invalidBase64Memo';
    expect(decodeSpotMemo(invalidMemo)).toStrictEqual({
      destId: undefined,
      exchangeName: undefined,
      limitPrice: undefined,
      refId: undefined,
      spotOrderType: undefined,
      tradingType: undefined,
    });
  });
});

describe.skip('decodeArbitrageMemo', () => {
  it('should decode a valid arbitrage memo correctly', () => {
    const decodedMemo = 'AR:CR:01:02:Z7GC:b0177350-ae29-43ec-a26e-d46f821e416e';
    const result = decodeArbitrageMemo(decodedMemo);
    expect(result).toEqual({
      tradingType: 'Arbitrage',
      action: 'create',
      exchangeAName: 'binance',
      exchangeBName: 'bitfinex',
      symbol: 'BTC/USDT-ERC20',
      traceId: 'b0177350-ae29-43ec-a26e-d46f821e416e',
    });
  });

  it('should return null for empty input', () => {
    const result = decodeArbitrageMemo('');
    expect(result).toBeNull();
  });

  it('should return null for invalid memo format', () => {
    const decodedMemo = 'AR:CR:01'; // Missing parts
    const result = decodeArbitrageMemo(decodedMemo);
    expect(result).toBeNull();
  });

  it('should return null when destId does not map to a symbol', () => {
    const decodedMemo = 'AR:CR:01:02:99';
    const result = decodeArbitrageMemo(decodedMemo);
    expect(result).toBeNull();
  });
});

describe.skip('decodeMarketMakingMemo', () => {
  it('should decode a valid market making memo correctly', () => {
    const decodedMemo = 'MM:DE:04:MX5C:b0177350-ae29-43ec-a26e-d46f821e416e';
    const result = decodeMarketMakingMemo(decodedMemo);
    expect(result).toEqual({
      tradingType: 'Market Making',
      action: 'deposit',
      exchangeName: 'okx',
      symbol: 'ETH/USDT-ERC20',
      traceId: 'b0177350-ae29-43ec-a26e-d46f821e416e',
    });
  });

  it('should return null for empty input', () => {
    const result = decodeMarketMakingMemo('');
    expect(result).toBeNull();
  });

  it('should return null for invalid memo format', () => {
    const decodedMemo = 'MM:CR:ETHUSD'; // Incorrect format
    expect(decodeMarketMakingMemo(decodedMemo)).toBeNull();
  });

  it('should return null when destId does not map to a symbol', () => {
    const decodedMemo = 'MM:CR:03:99'; // '99' does not map to any symbol
    const result = decodeMarketMakingMemo(decodedMemo);
    expect(result).toBeNull();
  });
});
